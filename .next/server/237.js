"use strict";exports.id=237,exports.ids=[237],exports.modules={49237:(e,t,s)=>{s.d(t,{qL:()=>d,ZP:()=>y,_B:()=>m});var r=s(53524),i=s(93475),a=s(34378);class n{constructor(e="fisioflow",t=104857600){this.memoryCache=new Map,this.currentMemorySize=0,this.responseTimes=[],this.prefix=e,this.maxMemorySize=t,this.metrics={hits:0,misses:0,hitRate:0,memoryHits:0,redisHits:0,operations:0,errors:0,avgResponseTime:0,totalSize:0},setInterval(()=>this.cleanupMemoryCache(),6e4)}getKey(e){return`${this.prefix}:${e}`}async get(e,t={}){let s=Date.now();this.metrics.operations++;try{let r=this.getKey(e),a=t.layer||"both";if("memory"===a||"both"===a){let e=this.getFromMemory(r);if(null!==e)return this.metrics.hits++,this.metrics.memoryHits++,this.updateMetrics(Date.now()-s),e}if("redis"===a||"both"===a){let e=await i.Z,n=await e.get(r);if(n){let e=this.deserialize(n,t.serialize);return"both"===a&&this.setInMemory(r,e,t.ttl),this.metrics.hits++,this.metrics.redisHits++,this.updateMetrics(Date.now()-s),e}}return this.metrics.misses++,this.updateMetrics(Date.now()-s),null}catch(t){return this.metrics.errors++,a.hY.error("Cache get error",t,{key:e,prefix:this.prefix}),null}}async set(e,t,s={}){let r=Date.now();this.metrics.operations++;try{let a=this.getKey(e),n=s.layer||"both",o=this.serialize(t,s.serialize,s.compress);if(("memory"===n||"both"===n)&&this.setInMemory(a,t,s.ttl),"redis"===n||"both"===n){let e=await i.Z;if(s.ttl?await e.set(a,o,{EX:s.ttl}):await e.set(a,o),s.tags)for(let t of s.tags){let r=this.getKey(`tag:${t}`);await e.sadd(r,a),s.ttl&&await e.expire(r,s.ttl+300)}}this.updateMetrics(Date.now()-r)}catch(t){this.metrics.errors++,a.hY.error("Cache set error",t,{key:e,prefix:this.prefix})}}async del(e){let t=Date.now();this.metrics.operations++;try{let s=this.getKey(e),r=this.memoryCache.get(s);r&&(this.currentMemorySize-=r.size,this.memoryCache.delete(s));let a=await i.Z;await a.del(s),this.updateMetrics(Date.now()-t)}catch(t){this.metrics.errors++,a.hY.error("Cache delete error",t,{key:e,prefix:this.prefix})}}async invalidateTag(e){let t=Date.now();this.metrics.operations++;try{let s=await i.Z,r=this.getKey(`tag:${e}`),n=await s.smembers(r);n.length>0&&(n.forEach(e=>{let t=this.memoryCache.get(e);t&&(this.currentMemorySize-=t.size,this.memoryCache.delete(e))}),await s.del(...n),await s.del(r)),this.updateMetrics(Date.now()-t),a.hY.info("Cache tag invalidated",{tag:e,keysCount:n.length})}catch(t){this.metrics.errors++,a.hY.error("Cache tag invalidation error",t,{tag:e})}}async clear(){let e=Date.now();this.metrics.operations++;try{this.memoryCache.clear(),this.currentMemorySize=0;let t=await i.Z,s=await t.keys(`${this.prefix}:*`);s.length>0&&await t.del(...s),this.updateMetrics(Date.now()-e),a.hY.info("Cache cleared",{prefix:this.prefix,keysCount:s.length})}catch(e){this.metrics.errors++,a.hY.error("Cache clear error",e,{prefix:this.prefix})}}async remember(e,t,s={}){let r=await this.get(e);if(null!==r)return r;let i=await t();return await this.set(e,i,s),i}async rememberForever(e,t,s=3600,r={}){let a=`${e}:refresh`,n=await i.Z,o=await n.get(this.getKey(a)),c=Date.now(),h=await this.get(e,r);if(!h||!o||c-parseInt(o)>1e3*s)try{let s=await t();return await this.set(e,s,r),await n.set(this.getKey(a),c.toString()),s}catch(e){if(h)return h;throw e}return h}getFromMemory(e){let t=this.memoryCache.get(e);return t?t.expiry&&Date.now()>t.expiry?(this.currentMemorySize-=t.size,this.memoryCache.delete(e),null):t.value:null}setInMemory(e,t,s){let r=new Blob([JSON.stringify(t)]).size;this.currentMemorySize+r>this.maxMemorySize&&this.evictMemoryCache(r);let i=s?Date.now()+1e3*s:void 0;this.memoryCache.set(e,{value:t,expiry:i,size:r}),this.currentMemorySize+=r}evictMemoryCache(e){let t=Array.from(this.memoryCache.entries());t.sort((e,t)=>(e[1].expiry||1/0)-(t[1].expiry||1/0));let s=0;for(let[r,i]of t)if(this.memoryCache.delete(r),s+=i.size,this.currentMemorySize-=i.size,s>=e)break;a.hY.info("Memory cache evicted",{freedSpace:s,neededSize:e})}cleanupMemoryCache(){let e=Date.now(),t=0,s=0;for(let[r,i]of Array.from(this.memoryCache.entries()))i.expiry&&e>i.expiry&&(t+=i.size,s++,this.memoryCache.delete(r));this.currentMemorySize-=t,s>0&&a.hY.debug("Memory cache cleanup",{cleanedCount:s,cleanedSize:t})}serialize(e,t="json",s=!1){let r=JSON.stringify(e);return"msgpack"===t&&(r=JSON.stringify(e)),s&&r.length,r}deserialize(e,t="json"){return JSON.parse(e)}updateMetrics(e){this.responseTimes.push(e),this.responseTimes.length>1e3&&(this.responseTimes=this.responseTimes.slice(-1e3)),this.metrics.avgResponseTime=this.responseTimes.reduce((e,t)=>e+t,0)/this.responseTimes.length;let t=this.metrics.hits+this.metrics.misses;this.metrics.hitRate=t>0?this.metrics.hits/t*100:0,this.metrics.totalSize=this.currentMemorySize}getMetrics(){return{...this.metrics}}async getRedisStats(){try{return(await i.Z).getStats()}catch(e){return a.hY.error("Failed to get Redis stats",e),null}}async mget(e,t={}){return Promise.all(e.map(e=>this.get(e,t)))}async mset(e,t={}){await Promise.all(e.map(e=>this.set(e.key,e.value,t)))}}new n("patients",52428800),new n("appointments",31457280),new n("reports",104857600),new n("analytics",209715200),new n("sessions",20971520);let o=new n("queries",157286400);new n("default",104857600);var c=s(84770),h=s.n(c);let l=globalThis;class u{constructor(e){this.defaultTTL=300,this.queryStats={total:0,cached:0,fresh:0},this.prisma=e}createCachedProxy(){return new Proxy(this.prisma,{get:(e,t)=>"object"==typeof e[t]&&null!==e[t]?this.createModelProxy(e[t],t):e[t]})}createModelProxy(e,t){return new Proxy(e,{get:(e,s)=>this.isCacheableOperation(s)?this.createCachedOperation(e,t,s):e[s]})}isCacheableOperation(e){return["findFirst","findFirstOrThrow","findMany","findUnique","findUniqueOrThrow","count","aggregate","groupBy"].includes(e)}createCachedOperation(e,t,s){return async(r={})=>{this.queryStats.total++;let i=this.generateCacheKey(t,s,r),n=this.generateCacheTags(t,s,r),c=await o.get(i,{tags:n,layer:"both"});if(null!==c)return this.queryStats.cached++,a.hY.debug("Query served from cache",{model:t,operation:s,cacheKey:i}),c;let h=Date.now(),l=await e[s](r),u=Date.now()-h;this.queryStats.fresh++;let m=this.determineTTL(t,s,r);return await o.set(i,l,{ttl:m,tags:n,layer:"both",compress:this.shouldCompress(l)}),a.hY.debug("Query executed and cached",{model:t,operation:s,queryTime:u,ttl:m,cacheKey:i}),l}}generateCacheKey(e,t,s){let r=JSON.stringify(s,Object.keys(s).sort()),i=h().createHash("md5").update(r).digest("hex");return`query:${e}:${t}:${i}`}generateCacheTags(e,t,s){let r=[`model:${e}`,`operation:${t}`];return s.where&&(s.where.id&&r.push(`${e}:${s.where.id}`),s.where.userId&&r.push(`user:${s.where.userId}`)),r}determineTTL(e,t,s){return Math.floor(({User:1800,Patient:900,Appointment:300,Report:3600,Analytics:600}[e]||this.defaultTTL)*(({count:2,aggregate:2,findMany:1,findUnique:1.5})[t]||1))}shouldCompress(e){return JSON.stringify(e).length>1024}async invalidateModel(e){await o.invalidateTag(`model:${e}`),a.hY.info("Model cache invalidated",{model:e})}async invalidateRecord(e,t){await o.invalidateTag(`${e}:${t}`),a.hY.info("Record cache invalidated",{model:e,id:t})}async invalidateUser(e){await o.invalidateTag(`user:${e}`),a.hY.info("User cache invalidated",{userId:e})}getQueryStats(){let e=this.queryStats.total>0?this.queryStats.cached/this.queryStats.total*100:0;return{...this.queryStats,hitRate:parseFloat(e.toFixed(2))}}get direct(){return this.prisma}get client(){return this.createCachedProxy()}async $transaction(e){return this.prisma.$transaction(e)}async $disconnect(){return this.prisma.$disconnect()}async $connect(){return this.prisma.$connect()}$executeRaw(e){return this.prisma.$executeRaw(e)}$queryRaw(e){return this.prisma.$queryRaw(e)}}let m=l.prisma??new r.PrismaClient({log:["error"]}),d=l.cachedPrisma??new u(m),p=new r.PrismaClient({log:["error"],datasources:{db:{url:process.env.DATABASE_URL}}}),g=new u(p);if("undefined"!=typeof process&&process.on){let e=async e=>{a.hY.info(`Received ${e}, starting graceful shutdown`);try{let e=d.getQueryStats(),t=await o.getMetrics();a.hY.info("Final cache statistics",{queryStats:e,cacheStats:t}),await m.$disconnect(),await p.$disconnect(),await d.$disconnect(),await g.$disconnect(),a.hY.info("Graceful shutdown completed"),process.exit(0)}catch(e){a.hY.error("Error during graceful shutdown",e),process.exit(1)}};process.on("SIGINT",()=>e("SIGINT")),process.on("SIGTERM",()=>e("SIGTERM"))}let y=d},34378:(e,t,s)=>{let r;s.d(t,{hY:()=>c});var i=s(94624);let a=new(s(61212)).AsyncLocalStorage,n={level:process.env.LOG_LEVEL||"info",format:"true"===process.env.RAILWAY_STRUCTURED_LOGGING?"json":"simple",enableConsole:!0,enableFile:!0,maxFiles:parseInt(process.env.LOG_MAX_FILES||"5"),maxSize:process.env.LOG_MAX_SIZE||"10m",service:process.env.RAILWAY_SERVICE_NAME||"fisioflow",environment:process.env.RAILWAY_ENVIRONMENT||"production"};class o{constructor(){this.requestCount=0,this.errorCount=0,this.shutdownHandlers=[],this.isShuttingDown=!1,this.startTime=Date.now(),this.initializeLogger(),this.setupGracefulShutdown()}initializeLogger(){let e=i.format.combine(i.format.timestamp({format:"YYYY-MM-DD HH:mm:ss.SSS"}),i.format.errors({stack:!0}),i.format.json(),i.format.printf(e=>{let t=a.getStore()||{},s={timestamp:e.timestamp,level:e.level,message:e.message,service:n.service,environment:n.environment,...t,...e.meta};return e.stack&&(s.stack=e.stack),process.env.RAILWAY_GIT_COMMIT_SHA&&(s.commit=process.env.RAILWAY_GIT_COMMIT_SHA),process.env.RAILWAY_DEPLOYMENT_ID&&(s.deploymentId=process.env.RAILWAY_DEPLOYMENT_ID),JSON.stringify(s)})),t=i.format.combine(i.format.colorize(),i.format.timestamp({format:"HH:mm:ss"}),i.format.printf(e=>{let t=a.getStore(),s=t?.requestId?`[${t.requestId}] `:"";return`${e.timestamp} ${e.level}: ${s}${e.message}`})),s=[];n.enableConsole&&s.push(new i.transports.Console({format:"json"===n.format?e:t,handleExceptions:!0,handleRejections:!0})),n.enableFile&&s.push(new i.transports.File({filename:"/app/logs/error.log",level:"error",format:e,maxsize:n.maxSize,maxFiles:n.maxFiles}),new i.transports.File({filename:"/app/logs/combined.log",format:e,maxsize:n.maxSize,maxFiles:n.maxFiles})),this.logger=(0,i.createLogger)({level:n.level,transports:s,exitOnError:!1})}setupGracefulShutdown(){["SIGTERM","SIGINT","SIGUSR2"].forEach(e=>{process.on(e,async()=>{this.isShuttingDown&&(this.logger.warn("Shutdown j\xe1 em progresso, for\xe7ando sa\xedda..."),process.exit(1)),this.isShuttingDown=!0,this.logger.info(`Recebido sinal ${e}, iniciando graceful shutdown...`),await this.gracefulShutdown()})}),process.on("uncaughtException",e=>{this.logger.error("Uncaught Exception:",{error:e.message,stack:e.stack}),this.gracefulShutdown().then(()=>process.exit(1))}),process.on("unhandledRejection",(e,t)=>{this.logger.error("Unhandled Rejection:",{reason:e,promise:t})})}addShutdownHandler(e){this.shutdownHandlers.push(e)}async gracefulShutdown(){let e=parseInt(process.env.GRACEFUL_SHUTDOWN_TIMEOUT||"30000");this.logger.info("Iniciando graceful shutdown...",{uptime:Date.now()-this.startTime,requestCount:this.requestCount,errorCount:this.errorCount});let t=setTimeout(()=>{this.logger.error("Graceful shutdown timeout, for\xe7ando sa\xedda..."),process.exit(1)},e);try{await Promise.all(this.shutdownHandlers.map(async(e,t)=>{try{await e(),this.logger.debug(`Shutdown handler ${t} executado com sucesso`)}catch(e){this.logger.error(`Erro no shutdown handler ${t}:`,{error:e})}})),this.logger.info("Graceful shutdown conclu\xeddo com sucesso"),clearTimeout(t),process.exit(0)}catch(e){this.logger.error("Erro durante graceful shutdown:",{error:e}),clearTimeout(t),process.exit(1)}}createRequestMiddleware(){return e=>{let t=this.generateRequestId(),s={requestId:t,method:e.method,url:e.url,userAgent:e.headers.get("user-agent")||void 0,ip:e.headers.get("x-forwarded-for")||e.headers.get("x-real-ip")||void 0,timestamp:new Date().toISOString(),environment:n.environment,service:n.service};return this.requestCount++,a.run(s,()=>{let s=Date.now();return this.logger.info("Request iniciado",{method:e.method,url:e.url,requestId:t}),(r,i)=>{let a=Date.now()-s;i?(this.errorCount++,this.logger.error("Request falhou",{method:e.method,url:e.url,requestId:t,statusCode:r,duration:a,error:i.message,stack:i.stack})):this.logger.info("Request conclu\xeddo",{method:e.method,url:e.url,requestId:t,statusCode:r,duration:a})}})}}info(e,t){this.logger.info(e,{meta:t})}error(e,t,s){this.errorCount++,this.logger.error(e,{error:t instanceof Error?{message:t.message,stack:t.stack,name:t.name}:t,meta:s})}warn(e,t){this.logger.warn(e,{meta:t})}debug(e,t){this.logger.debug(e,{meta:t})}performance(e,t,s){this.logger.info(`Performance: ${e}`,{operation:e,...t,meta:s})}systemMetrics(){let e=process.memoryUsage(),t=process.cpuUsage(),s=Date.now()-this.startTime;this.logger.info("System metrics",{memory:{rss:Math.round(e.rss/1024/1024),heapUsed:Math.round(e.heapUsed/1024/1024),heapTotal:Math.round(e.heapTotal/1024/1024),external:Math.round(e.external/1024/1024)},cpu:{user:t.user,system:t.system},uptime:s,requestCount:this.requestCount,errorCount:this.errorCount,errorRate:this.requestCount>0?this.errorCount/this.requestCount*100:0})}generateRequestId(){return`req_${Date.now()}_${Math.random().toString(36).substring(2,9)}`}getMetrics(){return{uptime:Date.now()-this.startTime,requestCount:this.requestCount,errorCount:this.errorCount,errorRate:this.requestCount>0?this.errorCount/this.requestCount*100:0,isShuttingDown:this.isShuttingDown}}}let c=(r||(r=new o,"true"===process.env.RAILWAY_METRICS_ENABLED&&setInterval(()=>{r.systemMetrics()},parseInt(process.env.RAILWAY_METRICS_INTERVAL||"60000"))),r)},93475:(e,t,s)=>{s.d(t,{Z:()=>h});var r=s(79984),i=s(34378);class a{constructor(){this.store=new Map,this.connected=!0,this.startTime=Date.now(),this.stats={hits:0,misses:0,hitRate:0,operations:0,errors:0,uptime:0,connected:!0}}async get(e){this.stats.operations++;let t=this.store.get(e);return t?t.expiry&&Date.now()>t.expiry?(this.store.delete(e),this.stats.misses++,this.updateHitRate(),null):(this.stats.hits++,this.updateHitRate(),t.value):(this.stats.misses++,this.updateHitRate(),null)}async set(e,t,s){let r=s?.EX?Date.now()+1e3*s.EX:void 0;return this.store.set(e,{value:t,expiry:r}),"OK"}async del(...e){this.stats.operations++;let t=0;for(let s of e)this.store.delete(s)&&t++;return t}async exists(e){let t=this.store.get(e);return t?t.expiry&&Date.now()>t.expiry?(this.store.delete(e),0):1:0}async flushAll(){return this.store.clear(),"OK"}async ping(){return"PONG"}async keys(e){this.stats.operations++;let t=Array.from(this.store.keys()),s=new RegExp(e.replace(/\*/g,".*"));return t.filter(e=>s.test(e))}async sadd(e,...t){this.stats.operations++;let s=this.store.get(e),r=s?new Set(JSON.parse(s.value)):new Set,i=r.size;return t.forEach(e=>r.add(e)),this.store.set(e,{value:JSON.stringify(Array.from(r))}),r.size-i}async smembers(e){this.stats.operations++;let t=this.store.get(e);if(!t)return[];try{return JSON.parse(t.value)}catch{return[]}}async expire(e,t){this.stats.operations++;let s=this.store.get(e);return!!s&&(s.expiry=Date.now()+1e3*t,!0)}isConnected(){return this.connected}getStats(){return{...this.stats,uptime:Date.now()-this.startTime,connected:this.connected}}updateHitRate(){let e=this.stats.hits+this.stats.misses;this.stats.hitRate=e>0?this.stats.hits/e*100:0}}class n{constructor(e,t=!1,s=[]){this.connected=!1,this.startTime=Date.now(),this.fallbackClients=[],this.client=e,this.isCluster=t,this.fallbackClients=s,this.stats={hits:0,misses:0,hitRate:0,operations:0,errors:0,uptime:0,connected:!1,clusterNodes:t?1:void 0}}async get(e){return await this.executeWithFallback(async t=>{this.stats.operations++;let s=await t.get(e);return null===s?this.stats.misses++:this.stats.hits++,this.updateHitRate(),s})}async set(e,t,s){return s?.EX?await this.client.setEx(e,s.EX,t):await this.client.set(e,t)}async del(...e){return await this.executeWithFallback(async t=>(this.stats.operations++,await t.del(e)))}async exists(e){return await this.client.exists(e)}async flushAll(){return await this.client.flushAll()}async ping(){return await this.client.ping()}isConnected(){return this.connected&&this.client.isReady}async keys(e){return await this.executeWithFallback(async t=>(this.stats.operations++,await t.keys(e)))}async sadd(e,...t){return await this.executeWithFallback(async s=>(this.stats.operations++,await s.sAdd(e,t)))}async smembers(e){return await this.executeWithFallback(async t=>(this.stats.operations++,await t.sMembers(e)))}async expire(e,t){return await this.executeWithFallback(async s=>(this.stats.operations++,await s.expire(e,t)))}getStats(){return{...this.stats,uptime:Date.now()-this.startTime,connected:this.connected&&this.client.isReady}}setConnected(e){this.connected=e,this.stats.connected=e&&this.client.isReady}updateHitRate(){let e=this.stats.hits+this.stats.misses;this.stats.hitRate=e>0?this.stats.hits/e*100:0}async executeWithFallback(e){try{return await e(this.client)}catch(t){for(let s of(this.stats.errors++,i.hY.warn("Redis operation failed, trying fallback",{error:t}),this.fallbackClients))try{if(s.isReady)return await e(s)}catch(e){i.hY.warn("Fallback client failed",{error:e})}throw t}}}let o=globalThis,c=async()=>{process.env.REDIS_URL;let e=process.env.REDIS_CLUSTER_NODES?.split(",")||[],t=e.length>1;try{if(t){let t=(0,r.createCluster)({rootNodes:e.map(e=>({url:e.trim()})),defaults:{socket:{connectTimeout:5e3,reconnectStrategy:e=>!(e>3)&&Math.min(200*e,1e3)}}}),s=new n(t,!0),a=!1;return t.on("error",e=>{a||i.hY.error("Redis Cluster Error durante conex\xe3o inicial",e),s.setConnected(!1)}),t.on("connect",()=>{i.hY.info("Redis Cluster: Conectado com sucesso"),s.setConnected(!0)}),a=!0,await Promise.race([t.connect(),new Promise((e,t)=>setTimeout(()=>t(Error("Cluster connection timeout")),1e4))]),await t.ping(),i.hY.info("Redis Cluster: Conex\xe3o testada com sucesso"),s}{let e=(0,r.createClient)({url:process.env.REDIS_URL||"redis://localhost:6379",socket:{connectTimeout:3e3,lazyConnect:!0,reconnectStrategy:e=>!(e>3)&&Math.min(200*e,1e3)}}),t=(process.env.REDIS_FALLBACK_URLS?.split(",")||[]).map(e=>(0,r.createClient)({url:e.trim(),socket:{connectTimeout:3e3,lazyConnect:!0,reconnectStrategy:!1}})),s=new n(e,!1,t),a=!1;for(let r of(e.on("error",e=>{a||i.hY.error("Redis Error durante conex\xe3o inicial",e),s.setConnected(!1)}),e.on("connect",()=>{i.hY.info("Redis: Conectado com sucesso"),s.setConnected(!0)}),t))try{await r.connect(),i.hY.info("Redis Fallback: Cliente conectado")}catch(e){i.hY.warn("Redis Fallback: Falha na conex\xe3o",{error:e})}return a=!0,await Promise.race([e.connect(),new Promise((e,t)=>setTimeout(()=>t(Error("Connection timeout")),3e3))]),await e.ping(),i.hY.info("Redis: Conex\xe3o testada com sucesso"),s}}catch(e){return i.hY.warn("Redis n\xe3o dispon\xedvel, usando cache em mem\xf3ria",{error:e}),new a}},h=(async()=>o.redis?o.redis:await c())()}};