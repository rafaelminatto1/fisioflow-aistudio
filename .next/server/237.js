"use strict";exports.id=237,exports.ids=[237],exports.modules={10236:(e,t,s)=>{s.d(t,{Z:()=>i});class r{constructor(){this.metrics={requestCount:0,errorCount:0,errorRate:0,uptime:0,startTime:Date.now()},this.logLevel="info",this.serviceName="fisioflow",this.environment="development","undefined"!=typeof process&&process.env&&(this.logLevel=process.env.LOG_LEVEL||"info",this.serviceName=process.env.RAILWAY_SERVICE_NAME||"fisioflow",this.environment=process.env.RAILWAY_ENVIRONMENT||"production")}shouldLog(e){let t=["debug","info","warn","error"];return t.indexOf(e)>=t.indexOf(this.logLevel)}formatLog(e){let{level:t,message:s,timestamp:r,metadata:i,error:a}=e;return JSON.stringify({timestamp:r,level:t.toUpperCase(),service:this.serviceName,environment:this.environment,message:s,...i&&{metadata:i},...a&&{error:{name:a.name,message:a.message,stack:a.stack}}})}log(e,t,s,r){if(!this.shouldLog(e))return;let i={level:e,message:t,timestamp:new Date().toISOString(),metadata:r,error:s},a=this.formatLog(i);switch(e){case"debug":case"info":break;case"warn":console.warn(a);break;case"error":console.error(a),this.metrics.errorCount++}this.updateMetrics()}updateMetrics(){this.metrics.requestCount++,this.metrics.uptime=Date.now()-this.metrics.startTime,this.metrics.errorRate=this.metrics.requestCount>0?this.metrics.errorCount/this.metrics.requestCount*100:0}debug(e,t){this.log("debug",e,void 0,t)}info(e,t){this.log("info",e,void 0,t)}warn(e,t){this.log("warn",e,void 0,t)}error(e,t,s){this.log("error",e,t,s)}getMetrics(){return{...this.metrics,uptime:Date.now()-this.metrics.startTime}}createRequestMiddleware(){return e=>{let t=Date.now(),s=Math.random().toString(36).substring(7);return this.info("Requisi\xe7\xe3o recebida",{requestId:s,method:e.method,url:e.url,userAgent:e.headers.get("user-agent"),ip:e.headers.get("x-forwarded-for")||"unknown"}),(r,i)=>{let a=Date.now()-t;i?this.error("Erro na requisi\xe7\xe3o",i,{requestId:s,status:r,duration:a,method:e.method,url:e.url}):this.info("Resposta enviada",{requestId:s,status:r,duration:a,method:e.method,url:e.url})}}}measurePerformance(e,t){let s=Date.now();try{let r=t();if(r instanceof Promise)return r.then(t=>{let r=Date.now()-s;return this.debug(`Performance: ${e}`,{duration:r}),t}).catch(t=>{let r=Date.now()-s;throw this.error(`Performance error: ${e}`,t,{duration:r}),t});{let t=Date.now()-s;return this.debug(`Performance: ${e}`,{duration:t}),r}}catch(r){let t=Date.now()-s;throw this.error(`Performance error: ${e}`,r,{duration:t}),r}}}let i=new r},49237:(e,t,s)=>{s.d(t,{qL:()=>d,ZP:()=>w,_B:()=>m});var r=s(53524),i=s(93475),a=s(10236);class n{constructor(e="fisioflow",t=104857600){this.memoryCache=new Map,this.currentMemorySize=0,this.responseTimes=[],this.prefix=e,this.maxMemorySize=t,this.metrics={hits:0,misses:0,hitRate:0,memoryHits:0,redisHits:0,operations:0,errors:0,avgResponseTime:0,totalSize:0},setInterval(()=>this.cleanupMemoryCache(),6e4)}getKey(e){return`${this.prefix}:${e}`}async get(e,t={}){let s=Date.now();this.metrics.operations++;try{let r=this.getKey(e),a=t.layer||"both";if("memory"===a||"both"===a){let e=this.getFromMemory(r);if(null!==e)return this.metrics.hits++,this.metrics.memoryHits++,this.updateMetrics(Date.now()-s),e}if("redis"===a||"both"===a){let e=await i.Z,n=await e.get(r);if(n){let e=this.deserialize(n,t.serialize);return"both"===a&&this.setInMemory(r,e,t.ttl),this.metrics.hits++,this.metrics.redisHits++,this.updateMetrics(Date.now()-s),e}}return this.metrics.misses++,this.updateMetrics(Date.now()-s),null}catch(t){return this.metrics.errors++,a.Z.error("Cache get error",t instanceof Error?t:Error(String(t)),{key:e,prefix:this.prefix}),null}}async set(e,t,s={}){let r=Date.now();this.metrics.operations++;try{let a=this.getKey(e),n=s.layer||"both",o=this.serialize(t,s.serialize,s.compress);if(("memory"===n||"both"===n)&&this.setInMemory(a,t,s.ttl),"redis"===n||"both"===n){let e=await i.Z;if(s.ttl?await e.set(a,o,{EX:s.ttl}):await e.set(a,o),s.tags)for(let t of s.tags){let r=this.getKey(`tag:${t}`);await e.sadd(r,a),s.ttl&&await e.expire(r,s.ttl+300)}}this.updateMetrics(Date.now()-r)}catch(t){this.metrics.errors++,a.Z.error("Cache set error",t instanceof Error?t:Error(String(t)),{key:e,prefix:this.prefix})}}async del(e){let t=Date.now();this.metrics.operations++;try{let s=this.getKey(e),r=this.memoryCache.get(s);r&&(this.currentMemorySize-=r.size,this.memoryCache.delete(s));let a=await i.Z;await a.del(s),this.updateMetrics(Date.now()-t)}catch(t){this.metrics.errors++,a.Z.error("Cache delete error",t instanceof Error?t:Error(String(t)),{key:e,prefix:this.prefix})}}async invalidateTag(e){let t=Date.now();this.metrics.operations++;try{let s=await i.Z,r=this.getKey(`tag:${e}`),n=await s.smembers(r);n.length>0&&(n.forEach(e=>{let t=this.memoryCache.get(e);t&&(this.currentMemorySize-=t.size,this.memoryCache.delete(e))}),await s.del(...n),await s.del(r)),this.updateMetrics(Date.now()-t),a.Z.info("Cache tag invalidated",{tag:e,keysCount:n.length})}catch(t){this.metrics.errors++,a.Z.error("Cache tag invalidation error",t instanceof Error?t:Error(String(t)),{tag:e})}}async clear(){let e=Date.now();this.metrics.operations++;try{this.memoryCache.clear(),this.currentMemorySize=0;let t=await i.Z,s=await t.keys(`${this.prefix}:*`);s.length>0&&await t.del(...s),this.updateMetrics(Date.now()-e),a.Z.info("Cache cleared",{prefix:this.prefix,keysCount:s.length})}catch(e){this.metrics.errors++,a.Z.error("Cache clear error",e instanceof Error?e:Error(String(e)),{prefix:this.prefix})}}async remember(e,t,s={}){let r=await this.get(e);if(null!==r)return r;let i=await t();return await this.set(e,i,s),i}async rememberForever(e,t,s=3600,r={}){let a=`${e}:refresh`,n=await i.Z,o=await n.get(this.getKey(a)),c=Date.now(),h=await this.get(e,r);if(!h||!o||c-parseInt(o)>1e3*s)try{let s=await t();return await this.set(e,s,r),await n.set(this.getKey(a),c.toString()),s}catch(e){if(h)return h;throw e}return h}getFromMemory(e){let t=this.memoryCache.get(e);return t?t.expiry&&Date.now()>t.expiry?(this.currentMemorySize-=t.size,this.memoryCache.delete(e),null):t.value:null}setInMemory(e,t,s){let r=new Blob([JSON.stringify(t)]).size;this.currentMemorySize+r>this.maxMemorySize&&this.evictMemoryCache(r);let i=s?Date.now()+1e3*s:void 0;this.memoryCache.set(e,{value:t,expiry:i,size:r}),this.currentMemorySize+=r}evictMemoryCache(e){let t=Array.from(this.memoryCache.entries());t.sort((e,t)=>(e[1].expiry||1/0)-(t[1].expiry||1/0));let s=0;for(let[r,i]of t)if(this.memoryCache.delete(r),s+=i.size,this.currentMemorySize-=i.size,s>=e)break;a.Z.info("Memory cache evicted",{freedSpace:s,neededSize:e})}cleanupMemoryCache(){let e=Date.now(),t=0,s=0;for(let[r,i]of Array.from(this.memoryCache.entries()))i.expiry&&e>i.expiry&&(t+=i.size,s++,this.memoryCache.delete(r));this.currentMemorySize-=t,s>0&&a.Z.debug("Memory cache cleanup",{cleanedCount:s,cleanedSize:t})}serialize(e,t="json",s=!1){let r=JSON.stringify(e);return"msgpack"===t&&(r=JSON.stringify(e)),s&&r.length,r}deserialize(e,t="json"){return JSON.parse(e)}updateMetrics(e){this.responseTimes.push(e),this.responseTimes.length>1e3&&(this.responseTimes=this.responseTimes.slice(-1e3)),this.metrics.avgResponseTime=this.responseTimes.reduce((e,t)=>e+t,0)/this.responseTimes.length;let t=this.metrics.hits+this.metrics.misses;this.metrics.hitRate=t>0?this.metrics.hits/t*100:0,this.metrics.totalSize=this.currentMemorySize}getMetrics(){return{...this.metrics}}async getRedisStats(){try{return(await i.Z).getStats()}catch(e){return a.Z.error("Failed to get Redis stats",e instanceof Error?e:Error(String(e))),null}}async mget(e,t={}){return Promise.all(e.map(e=>this.get(e,t)))}async mset(e,t={}){await Promise.all(e.map(e=>this.set(e.key,e.value,t)))}}new n("patients",52428800),new n("appointments",31457280),new n("reports",104857600),new n("analytics",209715200),new n("sessions",20971520);let o=new n("queries",157286400);new n("default",104857600);var c=s(84770),h=s.n(c);let l=globalThis;class u{constructor(e){this.defaultTTL=300,this.queryStats={total:0,cached:0,fresh:0},this.prisma=e}createCachedProxy(){return new Proxy(this.prisma,{get:(e,t)=>"object"==typeof e[t]&&null!==e[t]?this.createModelProxy(e[t],t):e[t]})}createModelProxy(e,t){return new Proxy(e,{get:(e,s)=>this.isCacheableOperation(s)?this.createCachedOperation(e,t,s):e[s]})}isCacheableOperation(e){return["findFirst","findFirstOrThrow","findMany","findUnique","findUniqueOrThrow","count","aggregate","groupBy"].includes(e)}createCachedOperation(e,t,s){return async(r={})=>{this.queryStats.total++;let i=this.generateCacheKey(t,s,r),n=this.generateCacheTags(t,s,r),c=await o.get(i,{tags:n,layer:"both"});if(null!==c)return this.queryStats.cached++,a.Z.debug("Query served from cache",{model:t,operation:s,cacheKey:i}),c;let h=Date.now(),l=await e[s](r),u=Date.now()-h;this.queryStats.fresh++;let m=this.determineTTL(t,s,r);return await o.set(i,l,{ttl:m,tags:n,layer:"both",compress:this.shouldCompress(l)}),a.Z.debug("Query executed and cached",{model:t,operation:s,queryTime:u,ttl:m,cacheKey:i}),l}}generateCacheKey(e,t,s){let r=JSON.stringify(s,Object.keys(s).sort()),i=h().createHash("md5").update(r).digest("hex");return`query:${e}:${t}:${i}`}generateCacheTags(e,t,s){let r=[`model:${e}`,`operation:${t}`];return s.where&&(s.where.id&&r.push(`${e}:${s.where.id}`),s.where.userId&&r.push(`user:${s.where.userId}`)),r}determineTTL(e,t,s){return Math.floor(({User:1800,Patient:900,Appointment:300,Report:3600,Analytics:600}[e]||this.defaultTTL)*(({count:2,aggregate:2,findMany:1,findUnique:1.5})[t]||1))}shouldCompress(e){return JSON.stringify(e).length>1024}async invalidateModel(e){await o.invalidateTag(`model:${e}`),a.Z.info("Model cache invalidated",{model:e})}async invalidateRecord(e,t){await o.invalidateTag(`${e}:${t}`),a.Z.info("Record cache invalidated",{model:e,id:t})}async invalidateUser(e){await o.invalidateTag(`user:${e}`),a.Z.info("User cache invalidated",{userId:e})}getQueryStats(){let e=this.queryStats.total>0?this.queryStats.cached/this.queryStats.total*100:0;return{...this.queryStats,hitRate:parseFloat(e.toFixed(2))}}get direct(){return this.prisma}get client(){return this.createCachedProxy()}async $transaction(e){return this.prisma.$transaction(e)}async $disconnect(){return this.prisma.$disconnect()}async $connect(){return this.prisma.$connect()}$executeRaw(e){return this.prisma.$executeRaw(e)}$queryRaw(e){return this.prisma.$queryRaw(e)}}let m=l.prisma??new r.PrismaClient({log:["error"]}),d=l.cachedPrisma??new u(m),y=new r.PrismaClient({log:["error"],datasources:{db:{url:process.env.DATABASE_URL}}}),p=new u(y);if("undefined"!=typeof process&&process.on){let e=async e=>{a.Z.info(`Received ${e}, starting graceful shutdown`);try{let e=d.getQueryStats(),t=await o.getMetrics();a.Z.info("Final cache statistics",{queryStats:e,cacheStats:t}),await m.$disconnect(),await y.$disconnect(),await d.$disconnect(),await p.$disconnect(),a.Z.info("Graceful shutdown completed"),process.exit(0)}catch(e){a.Z.error("Error during graceful shutdown",e),process.exit(1)}};process.on("SIGINT",()=>e("SIGINT")),process.on("SIGTERM",()=>e("SIGTERM"))}let w=d},93475:(e,t,s)=>{s.d(t,{Z:()=>h});var r=s(79984),i=s(10236);class a{constructor(){this.store=new Map,this.connected=!0,this.startTime=Date.now(),this.stats={hits:0,misses:0,hitRate:0,operations:0,errors:0,uptime:0,connected:!0}}async get(e){this.stats.operations++;let t=this.store.get(e);return t?t.expiry&&Date.now()>t.expiry?(this.store.delete(e),this.stats.misses++,this.updateHitRate(),null):(this.stats.hits++,this.updateHitRate(),t.value):(this.stats.misses++,this.updateHitRate(),null)}async set(e,t,s){let r=s?.EX?Date.now()+1e3*s.EX:void 0;return this.store.set(e,{value:t,expiry:r}),"OK"}async del(...e){this.stats.operations++;let t=0;for(let s of e)this.store.delete(s)&&t++;return t}async exists(e){let t=this.store.get(e);return t?t.expiry&&Date.now()>t.expiry?(this.store.delete(e),0):1:0}async flushAll(){return this.store.clear(),"OK"}async ping(){return"PONG"}async keys(e){this.stats.operations++;let t=Array.from(this.store.keys()),s=new RegExp(e.replace(/\*/g,".*"));return t.filter(e=>s.test(e))}async sadd(e,...t){this.stats.operations++;let s=this.store.get(e),r=s?new Set(JSON.parse(s.value)):new Set,i=r.size;return t.forEach(e=>r.add(e)),this.store.set(e,{value:JSON.stringify(Array.from(r))}),r.size-i}async smembers(e){this.stats.operations++;let t=this.store.get(e);if(!t)return[];try{return JSON.parse(t.value)}catch{return[]}}async expire(e,t){this.stats.operations++;let s=this.store.get(e);return!!s&&(s.expiry=Date.now()+1e3*t,!0)}isConnected(){return this.connected}getStats(){return{...this.stats,uptime:Date.now()-this.startTime,connected:this.connected}}updateHitRate(){let e=this.stats.hits+this.stats.misses;this.stats.hitRate=e>0?this.stats.hits/e*100:0}}class n{constructor(e,t=!1,s=[]){this.connected=!1,this.startTime=Date.now(),this.fallbackClients=[],this.client=e,this.isCluster=t,this.fallbackClients=s,this.stats={hits:0,misses:0,hitRate:0,operations:0,errors:0,uptime:0,connected:!1,clusterNodes:t?1:void 0}}async get(e){return await this.executeWithFallback(async t=>{this.stats.operations++;let s=await t.get(e);return null===s?this.stats.misses++:this.stats.hits++,this.updateHitRate(),s})}async set(e,t,s){return s?.EX?await this.client.setEx(e,s.EX,t):await this.client.set(e,t)}async del(...e){return await this.executeWithFallback(async t=>(this.stats.operations++,await t.del(e)))}async exists(e){return await this.client.exists(e)}async flushAll(){return await this.executeWithFallback(async e=>(this.stats.operations++,await e.sendCommand(["FLUSHDB"])))}async ping(){return await this.executeWithFallback(async e=>(this.stats.operations++,await e.sendCommand(["PING"])))}isConnected(){return this.connected}async keys(e){return await this.executeWithFallback(async t=>(this.stats.operations++,await t.keys(e)))}async sadd(e,...t){return await this.executeWithFallback(async s=>(this.stats.operations++,await s.sAdd(e,t)))}async smembers(e){return await this.executeWithFallback(async t=>(this.stats.operations++,await t.sMembers(e)))}async expire(e,t){return await this.executeWithFallback(async s=>(this.stats.operations++,await s.expire(e,t)))}getStats(){return{...this.stats,uptime:Date.now()-this.startTime,connected:this.connected}}setConnected(e){this.connected=e,this.stats.connected=e}updateHitRate(){let e=this.stats.hits+this.stats.misses;this.stats.hitRate=e>0?this.stats.hits/e*100:0}async executeWithFallback(e){try{return await e(this.client)}catch(t){for(let s of(this.stats.errors++,i.Z.warn("Redis operation failed, trying fallback",{error:t}),this.fallbackClients))try{if(s.isReady)return await e(s)}catch(e){i.Z.warn("Fallback client failed",{error:e})}throw t}}}let o=globalThis,c=async()=>{process.env.REDIS_URL;let e=process.env.REDIS_CLUSTER_NODES?.split(",")||[],t=e.length>1;try{if(t){let t=(0,r.createCluster)({rootNodes:e.map(e=>({url:e.trim()})),defaults:{socket:{connectTimeout:5e3,reconnectStrategy:e=>!(e>3)&&Math.min(200*e,1e3)}}}),s=new n(t,!0),a=!1;t.on("error",e=>{a||i.Z.error("Redis Cluster Error durante conex\xe3o inicial",e),s.setConnected(!1)}),t.on("connect",()=>{i.Z.info("Redis Cluster: Conectado com sucesso"),s.setConnected(!0)}),a=!0,await Promise.race([t.connect(),new Promise((e,t)=>setTimeout(()=>t(Error("Cluster connection timeout")),1e4))]);try{await t.get("__ping_test__"),i.Z.info("Redis Cluster: Conex\xe3o testada com sucesso")}catch(e){i.Z.info("Redis Cluster: Conex\xe3o estabelecida")}return s}{let e=(0,r.createClient)({url:process.env.REDIS_URL||"redis://localhost:6379",socket:{connectTimeout:3e3,reconnectStrategy:e=>!(e>3)&&Math.min(200*e,1e3)}}),t=(process.env.REDIS_FALLBACK_URLS?.split(",")||[]).map(e=>(0,r.createClient)({url:e.trim(),socket:{connectTimeout:3e3,reconnectStrategy:!1}})),s=new n(e,!1,t),a=!1;for(let r of(e.on("error",e=>{a||i.Z.error("Redis Error durante conex\xe3o inicial",e),s.setConnected(!1)}),e.on("connect",()=>{i.Z.info("Redis: Conectado com sucesso"),s.setConnected(!0)}),t))try{await r.connect(),i.Z.info("Redis Fallback: Cliente conectado")}catch(e){i.Z.warn("Redis Fallback: Falha na conex\xe3o",{error:e})}a=!0,await Promise.race([e.connect(),new Promise((e,t)=>setTimeout(()=>t(Error("Connection timeout")),3e3))]);try{await e.get("__ping_test__"),i.Z.info("Redis: Conex\xe3o testada com sucesso")}catch(e){i.Z.info("Redis: Conex\xe3o estabelecida")}return s}}catch(e){return i.Z.warn("Redis n\xe3o dispon\xedvel, usando cache em mem\xf3ria",{error:e}),new a}},h=(async()=>o.redis?o.redis:await c())()}};